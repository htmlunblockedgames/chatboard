<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Poly Track Chatboard</title>
  <style>
    :root{
      --bg:#0b1021;--panel:#121735;--muted:#7c86b2;--text:#e7eaf6;--accent:#7aa2ff;--danger:#ff6b6b;--ok:#48e1a8;--border:#1d2450
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--text)}
    header{padding:18px 16px;border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between}
    header h1{margin:0;font-size:18px;letter-spacing:.3px}
    .status{font-size:12px;padding:6px 10px;border:1px solid var(--border);border-radius:999px;background:#0f1440}
    .status.ok{color:var(--ok)}
    .status.bad{color:var(--danger)}
    .container{max-width:920px;margin:0 auto;padding:16px;display:grid;gap:16px}
    .panel{background:var(--panel);border:1px solid var(--border);border-radius:16px}
    #composer{padding:12px;display:grid;gap:10px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .row-slim{gap:6px}
    input[type="text"],textarea{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#0f1440;color:var(--text)}
    textarea{min-height:100px;resize:vertical}
    .btn{padding:10px 12px;border-radius:10px;border:1px solid var(--border);background:#1a235a;color:#fff;cursor:pointer}
    .btn.primary{background:linear-gradient(180deg,#3b63ff,#2748cf)}
    .btn:disabled{opacity:.6;cursor:not-allowed}
    /* pretty file button */
    #file{display:none}
    .file-btn{display:inline-block}
    .file-name{font-size:12px;color:var(--muted)}
    #status{display:none;padding:10px 12px;border-top:1px solid var(--border);color:var(--muted);font-size:12px}
    #messages{padding:12px;display:flex;flex-direction:column;gap:10px;min-height:40vh}
    .msg{display:flex;gap:10px;padding:10px 12px;border:1px solid var(--border);border-radius:12px;background:rgba(255,255,255,.02)}
    .avatar{width:38px;height:38px;border-radius:50%;background:#2a3164;display:flex;align-items:center;justify-content:center;font-weight:700;color:#c9d3ff;flex:0 0 38px;overflow:hidden}
    .avatar img{width:100%;height:100%;object-fit:cover}
    .bubble{flex:1;min-width:0}
    .meta{font-size:12px;color:var(--muted);display:flex;gap:8px;align-items:center}
    .nick{color:#cfe0ff;font-weight:600}
    .content{margin-top:6px;line-height:1.5;word-wrap:break-word}
    .content img{max-width:420px;border-radius:10px;border:1px solid var(--border);display:block;margin:6px 0}
    .children{margin-top:8px;padding-left:46px;display:flex;flex-direction:column;gap:8px}
    #loadMore{margin:8px auto 16px;display:block}
    a{color:var(--accent)}
  </style>
</head>
<body>
  <header>
    <h1>Poly Track Chatboard</h1>
    <div id="conn" class="status">Status: checking…</div>
  </header>

  <main class="container">
    <!-- Composer first -->
    <section id="composer" class="panel">
      <div class="row">
        <input id="nick" type="text" placeholder="Nickname (optional, default Anonymous)"/>
      </div>
      <div class="row">
        <textarea id="text" placeholder="Type your message… You can also attach an image."></textarea>
      </div>
      <div class="row row-slim">
        <label for="file" class="btn file-btn" id="btnChoose">Choose image</label>
        <input id="file" type="file" accept="image/*"/>
        <span id="fileInfo" class="file-name"></span>
        <button id="btnAttach" class="btn">Attach image</button>
        <button id="btnSend" class="btn primary">Send</button>
      </div>
      <div id="status">Ready.</div>
    </section>

    <!-- Messages below -->
    <section class="panel">
      <div id="messages"></div>
      <button id="loadMore" class="btn primary" style="display:none">Load older</button>
    </section>
  </main>

  <script>
  ;(() => {
    // ====== EDIT THESE IF YOU MOVE HOST/PATH ======
    const WORKER_URL = "https://twikoo-cloudflare.ertertertet07.workers.dev";
    const PAGE_URL_PATH = "/chatboard/";
    const PAGE_HREF = "https://htmlunblockedgames.github.io/chatboard/";
    // ==============================================

    // DOM
    const $ = id => document.getElementById(id);
    const messagesEl = $("messages");
    const loadMoreBtn = $("loadMore");
    const nickEl = $("nick");
    const textEl = $("text");
    const fileEl = $("file");
    const btnChoose = $("btnChoose");
    const btnAttach = $("btnAttach");
    const btnSend = $("btnSend");
    const fileInfo = $("fileInfo");
    const statusEl = $("status");
    const connEl = $("conn");

    // State
    let earliestMainCreated = null; // for pagination
    let loading = false;
    let TK_TOKEN = localStorage.getItem('twikoo_access_token') || null;

    // Utils
    const setStatus = (t, isError=false) => {
      if (!t) { statusEl.style.display = "none"; statusEl.textContent = ""; return; }
      statusEl.style.display = "block";
      statusEl.textContent = t;
      statusEl.style.color = isError ? "var(--danger)" : "var(--muted)";
    };
    const fmtTime = ts => new Date(ts).toLocaleString();
    const initialOf = s => (s || "A").trim().charAt(0).toUpperCase();

    // API with token persistence
    async function api(eventObj) {
      const payload = { ...eventObj };
      if (TK_TOKEN) payload.accessToken = TK_TOKEN;

      const res = await fetch(WORKER_URL, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload)
      });
      const json = await res.json().catch(() => ({}));

      if (json && json.accessToken) {
        TK_TOKEN = json.accessToken;
        localStorage.setItem('twikoo_access_token', TK_TOKEN);
      }
      return json;
    }

    async function checkConnection() {
      try {
        const r = await api({ event: "GET_FUNC_VERSION" });
        connEl.textContent = "Status: Online";
        connEl.classList.remove("bad"); connEl.classList.add("ok");
      } catch {
        connEl.textContent = "Status: Offline";
        connEl.classList.remove("ok"); connEl.classList.add("bad");
      }
    }

    // Load newest page
    async function loadLatest() {
      if (loading) return;
      loading = true;
      setStatus("Loading messages…");
      try {
        const r = await api({ event: "COMMENT_GET", url: PAGE_URL_PATH });
        const list = Array.isArray(r?.data) ? r.data : [];
        renderComments(list);
        // compute earliest top-level created for pagination
        const tops = list.filter(c => (c.rid || "") === "");
        if (tops.length) {
          earliestMainCreated = Math.min(...tops.map(c => c.created || Date.now()));
          loadMoreBtn.style.display = "inline-block";
          loadMoreBtn.disabled = false;
          loadMoreBtn.textContent = "Load older";
        } else {
          earliestMainCreated = null;
          loadMoreBtn.style.display = "none";
        }
      } catch (e) {
        setStatus("Failed to load messages.", true);
      } finally {
        loading = false;
        setStatus(""); // no idle text
      }
    }

    // Append older page at the bottom
    async function loadOlder() {
      if (loading || !earliestMainCreated) return;
      loading = true;
      loadMoreBtn.disabled = true;
      loadMoreBtn.textContent = "Loading…";
      try {
        const r = await api({
          event: "COMMENT_GET",
          url: PAGE_URL_PATH,
          before: earliestMainCreated
        });
        const data = Array.isArray(r?.data) ? r.data : [];
        if (data.length) {
          appendComments(data); // append to bottom (older messages)
          const tops = data.filter(c => (c.rid || "") === "");
          if (tops.length) {
            earliestMainCreated = Math.min(earliestMainCreated, ...tops.map(c => c.created || Date.now()));
            loadMoreBtn.disabled = false;
            loadMoreBtn.textContent = "Load older";
          } else {
            loadMoreBtn.textContent = "No more";
          }
        } else {
          loadMoreBtn.textContent = "No more";
        }
      } catch (e) {
        setStatus("Failed loading older.", true);
        loadMoreBtn.disabled = false;
        loadMoreBtn.textContent = "Load older";
      } finally {
        loading = false;
      }
    }

    async function sendMessage() {
      const nick = nickEl.value.trim() || "Anonymous";
      const html = textEl.value.trim();
      if (!html) {
        setStatus("Type a message first.", true);
        return;
      }
      btnSend.disabled = true;
      btnSend.textContent = "Sending…";
      setStatus("Sending…");
      try {
        const r = await api({
          event: "COMMENT_SUBMIT",
          nick,
          comment: html,
          url: PAGE_URL_PATH,
          href: PAGE_HREF,
          ua: navigator.userAgent
        });
        if (r && r.id) {
          textEl.value = "";
          fileEl.value = "";
          fileInfo.textContent = "";
          await loadLatest(); // refresh to see new message
        } else {
          const raw = r?.message || "Unknown error";
          const pretty = prettifyError(raw);
          throw new Error(pretty);
        }
      } catch (e) {
        setStatus("Send failed: " + e.message, true);
      } finally {
        btnSend.disabled = false;
        btnSend.textContent = "Send";
      }
    }

    // Convert server CN rate-limit messages -> friendly EN
    function prettifyError(msg) {
      if (!msg) return "Unexpected error";
      if (msg.includes("发言频率过高")) return "You're sending too fast. Please wait a little and try again.";
      if (msg.includes("评论太火爆")) return "Chat is busy right now — please try again in a moment.";
      if (msg.includes("验证码")) return "Captcha check failed.";
      return msg;
    }

    async function attachImage() {
      const f = fileEl.files && fileEl.files[0];
      if (!f) { setStatus("Choose an image file first.", true); return; }
      btnAttach.disabled = true;
      btnAttach.textContent = "Uploading…";
      setStatus("Uploading image…");
      try {
        const dataURL = await fileToDataURL(f);
        const r = await api({ event: "UPLOAD_IMAGE", photo: dataURL });
        if (r?.code === 0 && r?.data?.url) {
          const url = r.data.url;
          insertAtCursor(textEl, `\n<img src="${url}" alt="">\n`);
          setStatus(""); // no idle text
        } else {
          const raw = r?.err || r?.message || "Upload failed";
          throw new Error(raw);
        }
      } catch (e) {
        setStatus("Image upload failed: " + e.message, true);
      } finally {
        btnAttach.disabled = false;
        btnAttach.textContent = "Attach image";
      }
    }

    // Rendering
    function renderComments(list) {
      messagesEl.innerHTML = "";
      appendComments(list);
    }

    // Append a page (older set) to the bottom
    function appendComments(list) {
      const tops = list.filter(c => (c.rid || "") === "");
      for (const c of tops) {
        messagesEl.appendChild(renderMsg(c));
        if (Array.isArray(c.children) && c.children.length) {
          const childrenWrap = document.createElement("div");
          childrenWrap.className = "children";
          for (const ch of c.children) childrenWrap.appendChild(renderMsg(ch, true));
          messagesEl.lastElementChild.appendChild(childrenWrap);
        }
      }
    }

    function renderMsg(c, isChild=false) {
      const wrap = document.createElement("div");
      wrap.className = "msg";

      const avatar = document.createElement("div");
      avatar.className = "avatar";
      if (c.avatar) {
        const img = document.createElement("img");
        img.src = c.avatar;
        img.alt = c.nick || "avatar";
        avatar.appendChild(img);
      } else {
        avatar.textContent = initialOf(c.nick);
      }

      const bubble = document.createElement("div");
      bubble.className = "bubble";

      const meta = document.createElement("div");
      meta.className = "meta";
      const nick = document.createElement("span");
      nick.className = "nick";
      nick.textContent = c.nick || "Anonymous";
      const time = document.createElement("span");
      time.textContent = fmtTime(c.created || Date.now());
      meta.appendChild(nick);
      meta.appendChild(time);

      const content = document.createElement("div");
      content.className = "content";
      content.innerHTML = c.comment || "";

      bubble.appendChild(meta);
      bubble.appendChild(content);

      wrap.appendChild(avatar);
      wrap.appendChild(bubble);
      return wrap;
    }

    // Helpers
    function fileToDataURL(file) {
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onerror = () => reject(fr.error || new Error("FileReader error"));
        fr.onload = () => resolve(fr.result);
        fr.readAsDataURL(file);
      });
    }
    function insertAtCursor(el, text) {
      const [start, end] = [el.selectionStart ?? el.value.length, el.selectionEnd ?? el.value.length];
      el.value = el.value.slice(0, start) + text + el.value.slice(end);
      const pos = start + text.length;
      el.setSelectionRange(pos, pos);
      el.focus();
    }

    // Wire up
    btnSend.addEventListener("click", sendMessage);
    btnAttach.addEventListener("click", attachImage);
    loadMoreBtn.addEventListener("click", loadOlder);
    fileEl.addEventListener("change", () => {
      const f = fileEl.files && fileEl.files[0];
      fileInfo.textContent = f ? f.name : "";
    });

    // Drag & drop onto the textarea
    textEl.addEventListener("dragover", e => { e.preventDefault(); });
    textEl.addEventListener("drop", async e => {
      e.preventDefault();
      const f = e.dataTransfer?.files?.[0];
      if (f && f.type.startsWith("image/")) {
        fileEl.files = e.dataTransfer.files;
        fileInfo.textContent = f.name;
        await attachImage();
      }
    });

    // Init
    checkConnection();
    loadLatest();
  })();
  </script>
</body>
</html>
